#!/usr/bin/env bash
# secure-codex
#
# Linux only (requires /dev/shm tmpfs).
# Keeps your existing ~/.codex directory (config, caches, etc.).
# Creates a CODEX_HOME in RAM (/dev/shm), symlinks everything except auth.json/auth.json.age,
# decrypts auth.json into RAM, validates it, and runs codex.
# The decrypted session is cached across invocations (cleared on reboot or SECURE_CODEX_CLEANUP=true).

set -euo pipefail

# ---- OS check ----
if [[ "$(uname -s)" != "Linux" ]]; then
	echo "Error: secure-codex only supports Linux (requires /dev/shm)."
	exit 1
fi

AUTH_ENC="${SECURE_CODEX_AUTH_ENC:-${HOME}/.codex/auth.json.age}"
REAL_CODEX_HOME="${SECURE_CODEX_REAL_CODEX_HOME:-${HOME}/.codex}"
CLEANUP_RAW="${SECURE_CODEX_CLEANUP:-false}"
case "${CLEANUP_RAW,,}" in
1 | true | yes | on)
	CLEANUP=true
	;;
"" | 0 | false | no | off)
	CLEANUP=false
	;;
*)
	echo "Error: SECURE_CODEX_CLEANUP must be one of: true,false,1,0,yes,no,on,off"
	exit 2
	;;
esac

# ---- tool checks ----
for tool in codex age jq ln rm mkdir mktemp chmod uname basename readlink stat date; do
	if ! command -v "$tool" >/dev/null 2>&1; then
		echo "Error: required tool not found: $tool"
		exit 1
	fi
done

if [[ ! -d "$REAL_CODEX_HOME" ]]; then
	echo "Error: real Codex home not found: $REAL_CODEX_HOME"
	exit 1
fi

if [[ ! -f "$AUTH_ENC" ]]; then
	echo "Error: encrypted auth file not found: $AUTH_ENC"
	exit 1
fi

if [[ ! -d /dev/shm || ! -w /dev/shm ]]; then
	echo "Error: /dev/shm is not available or not writable on this host."
	echo "Tip: if this is a cluster, ask for tmpfs access or use a trusted machine."
	exit 1
fi

umask 077

RAM_HOME="/dev/shm/codex-home-$(id -u)"

validate_ram_home() {
	if [[ -L "$RAM_HOME" ]]; then
		echo "Error: RAM home must not be a symlink: $RAM_HOME"
		return 1
	fi
	if [[ ! -d "$RAM_HOME" ]]; then
		echo "Error: RAM home exists but is not a directory: $RAM_HOME"
		return 1
	fi
	if [[ ! -O "$RAM_HOME" ]]; then
		echo "Error: RAM home is not owned by the current user: $RAM_HOME"
		return 1
	fi
	if ! chmod 700 "$RAM_HOME"; then
		echo "Error: failed to set secure permissions on RAM home: $RAM_HOME"
		return 1
	fi
}

# Handle SECURE_CODEX_CLEANUP=true
if [[ "$CLEANUP" == true ]]; then
	[[ "$RAM_HOME" == /dev/shm/* ]] || {
		echo "Error: refusing to rm outside /dev/shm"
		exit 1
	}
	if [[ -e "$RAM_HOME" ]]; then
		if rm -rf -- "$RAM_HOME"; then
			if [[ -e "$RAM_HOME" ]]; then
				echo "Error: cleanup incomplete for $RAM_HOME"
				exit 1
			fi
			echo "Cleaned up $RAM_HOME"
		else
			echo "Error: failed to clean up $RAM_HOME"
			exit 1
		fi
	else
		echo "Nothing to clean: $RAM_HOME"
	fi
	exit 0
fi

# ---- TTL validation (only needed for non-cleanup runs) ----
TTL="${SECURE_CODEX_TTL:-86400}" # seconds before auto-cleanup (default: 1 day)

if ! [[ "$TTL" =~ ^[0-9]+$ ]]; then
	echo "Error: SECURE_CODEX_TTL must be a non-negative integer (got: '$TTL')"
	exit 2
fi

if [[ -e "$RAM_HOME" ]]; then
	if ! validate_ram_home; then
		echo "Tip: run with SECURE_CODEX_CLEANUP=true after fixing ownership/perms."
		exit 1
	fi
fi

# Auto-cleanup stale sessions exceeding TTL
if [[ -f "${RAM_HOME}/auth.json" ]]; then
	auth_mtime="$(stat -c %Y "${RAM_HOME}/auth.json" 2>/dev/null || echo 0)"
	now="$(date +%s)"
	age_secs=$(( now - auth_mtime ))
	if (( age_secs >= 10#$TTL )); then
		echo "Session expired (${age_secs}s old, TTL=${TTL}s). Re-decrypting."
		[[ "$RAM_HOME" == /dev/shm/* ]] || {
			echo "Error: refusing to rm outside /dev/shm"
			exit 1
		}
		rm -rf -- "$RAM_HOME"
	fi
fi

# Reuse existing session if auth.json is present and valid
if [[ -f "${RAM_HOME}/auth.json" ]] && jq -e . "${RAM_HOME}/auth.json" >/dev/null 2>&1; then
	# Refresh symlinks in case REAL_CODEX_HOME contents changed
	shopt -s dotglob nullglob
	for path in "${REAL_CODEX_HOME}"/*; do
		base="$(basename "$path")"
		if [[ "$base" == "auth.json" || "$base" == "auth.json.age" ]]; then
			continue
		fi
		# Resolve symlinks to their real target to avoid broken chains
		if [[ -L "$path" ]]; then
			real_target="$(readlink -f "$path" 2>/dev/null || true)"
			if [[ -n "$real_target" ]]; then
				ln -sf -- "$real_target" "${RAM_HOME}/${base}"
			else
				# Dangling symlink — link to the symlink itself
				ln -sf -- "$path" "${RAM_HOME}/${base}"
			fi
		else
			ln -sf -- "$path" "${RAM_HOME}/${base}"
		fi
	done
	shopt -u dotglob nullglob
else
	# Fresh setup
	[[ "$RAM_HOME" == /dev/shm/* ]] || {
		echo "Error: refusing to rm outside /dev/shm"
		exit 1
	}
	rm -rf "$RAM_HOME" 2>/dev/null || true
	mkdir -p "$RAM_HOME"
	chmod 700 "$RAM_HOME"
	validate_ram_home || exit 1

	# Symlink everything from REAL_CODEX_HOME into RAM_HOME, except auth files
	shopt -s dotglob nullglob
	for path in "${REAL_CODEX_HOME}"/*; do
		base="$(basename "$path")"
		if [[ "$base" == "auth.json" || "$base" == "auth.json.age" ]]; then
			continue
		fi
		# Resolve symlinks to their real target to avoid broken chains
		if [[ -L "$path" ]]; then
			real_target="$(readlink -f "$path" 2>/dev/null || true)"
			if [[ -n "$real_target" ]]; then
				ln -s -- "$real_target" "${RAM_HOME}/${base}"
			else
				# Dangling symlink — link to the symlink itself
				ln -s -- "$path" "${RAM_HOME}/${base}"
			fi
		else
			ln -s -- "$path" "${RAM_HOME}/${base}"
		fi
	done
	shopt -u dotglob nullglob

	# Decrypt plaintext auth.json into RAM, using a unique temp file then atomic move
	tmp_auth="$(mktemp "${RAM_HOME}/.auth.json.tmp.XXXXXX")"
	cleanup_tmp_auth() {
		rm -f "$tmp_auth" 2>/dev/null || true
	}
	trap cleanup_tmp_auth EXIT
	if ! age -d -o "$tmp_auth" -- "$AUTH_ENC"; then
		echo "Error: failed to decrypt $AUTH_ENC"
		exit 1
	fi
	chmod 600 "$tmp_auth"

	# Validate JSON structure
	if ! jq -e . "$tmp_auth" >/dev/null 2>&1; then
		echo "Error: decrypted auth.json is not valid JSON"
		exit 1
	fi

	mv -f "$tmp_auth" "${RAM_HOME}/auth.json"
fi

# Run codex using RAM CODEX_HOME
export CODEX_HOME="$RAM_HOME"
codex "$@"
